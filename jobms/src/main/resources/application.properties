#spring.application.name=job-service
# disabled since it is picked from config server

server.port=8082

#h2 database
#spring.h2.console.enabled=true
#spring.datasource.url=jdbc:h2:mem:test
#spring.jpa.show-sql=true
#spring.jpa.hibernate.ddl-auto=update

#postgres db
spring.datasource.url=jdbc:postgresql://localhost:5432/job
spring.datasource.username=embarkx
spring.datasource.password=embarkx
spring.jpa.database=POSTGRESQL
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

#Eureka
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
# url used by jobms to register as a client in service registry
eureka.client.register-with-eureka=true
# jobms need to register with eureka server
eureka.client.fetch-registry=true
# jobms need to register with service registry

#Zipkin - In prod sample rate is reduced, since we don't need to trace every request -> it slows the system
management.tracing.sampling.probability=1.0
management.tracing.enabled=true

#Config Server Client
#spring.config.import=configserver:http://localhost:8080
# if we stop config server and start jobms, it may give error since communication is not established with both.
# so to avoid runtime error, we can set jobms as optional, but provide application name at that time(uncomment line 1),
# if not, application name will be UNKNOWN
spring.config.import=optional:configserver:http://localhost:8080

# to explicitly set application without launching default application
# <profile>.properties or application-<profile>.yml for profile-specific configuration (<profile> is replaced by the value of spring.profiles.active).
spring.profiles.active=dev

# Resilience4J - Circuit breaker -> 3 states: closed, half open, open
# test by downing companyms
# Enable health indicator registration for companyBreaker(instance of circuit breaker) in Actuator
resilience4j.circuitbreaker.instances.companyBreaker.registerHealthIndicator=true
# Set the sliding window size to 10 calls for the companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.slidingWindowSize=10
# Minimum 5 calls are required to evaluate the circuit for companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.minimumNumberOfCalls=5
# Allow up to 3 calls when in half-open state for companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.permittedNumberOfCallsInHalfOpenState=3
# Time duration to keep the circuit open before transitioning to half-open state (10 seconds)
resilience4j.circuitbreaker.instances.companyBreaker.waitDurationInOpenState=10s
# Set the failure rate threshold to 50% for companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.failureRateThreshold=50
# Register the health indicator explicitly for companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.register-health-indicator=true
# Enable automatic transition from open to half-open state for companyBreaker
resilience4j.circuitbreaker.instances.companyBreaker.automatic-transition-from-open-to-half-open-enabled=true
# Use count-based sliding window type for the companyBreaker circuit breaker
resilience4j.circuitbreaker.instances.companyBreaker.sliding-window-type=count_based

# Actuator configuration
# Enable health checks for circuit breakers and rate limiter in Actuator
management.health.circuitbreakers.enabled=true
management.health.ratelimiters.enabled=true
# Include the "health" endpoint in the exposed Actuator endpoints
management.endpoints.web.exposure.include=health
# Always show health details in Actuator responses
management.endpoint.health.show-details=always

# Resilience4J - Retry
# test by downing companyms
# Configure Retry for 'companyBreaker' with maximum 5 attempts
resilience4j.retry.instances.companyBreaker.max-attempts=5
# and 2 seconds wait duration between attempts
resilience4j.retry.instances.companyBreaker.wait-duration=2s

# Resilience4J - Rate Limiter
# test by up companyms, using jmeter
# Specifies how long to wait for permission before failing immediately when set to zero.
resilience4j.ratelimiter.instances.companyBreaker.timeout-duration=0s
# Defines the time interval (in seconds) to refresh the rate limiter's permissions.
resilience4j.ratelimiter.instances.companyBreaker.limit-refresh-period=4s
# Sets the maximum number of requests allowed during each refresh period.
resilience4j.ratelimiter.instances.companyBreaker.limit-for-period=2

#logging configuration to trace the RateLimiter behavior:
logging.level.io.github.resilience4j.ratelimiter=DEBUG
logging.level.io.github.resilience4j=DEBUG
logging.level.org.springframework.web=DEBUG
